## Floyd Cycle Detection Algorithm

### 1. Introduction

One of the most elegant algorithms used in data structures is **Floyd’s Cycle Detection Algorithm**, also known as the **Tortoise and Hare Algorithm**.

It is primarily used to detect **cycles in linked lists**, but the idea is much more powerful and appears in many problems such as:

- detecting cycles in linked lists
- finding duplicate numbers in arrays
- detecting cycles in sequences generated by functions
- solving some graph-like problems without explicitly building graphs

The algorithm is famous because it solves these problems with:

    O(n) time
    O(1) extra space

No hash maps, no extra arrays — just pointer movement.

---

### 2. The Core Idea

The algorithm uses **two pointers moving at different speeds**.

These pointers are commonly called:

    slow pointer (tortoise)
    fast pointer (hare)

The idea is:

- slow moves **1 step at a time**
- fast moves **2 steps at a time**

If a **cycle exists**, the fast pointer will eventually catch the slow pointer inside the cycle.

If no cycle exists, the fast pointer reaches the end of the structure.

---

### 3. Why Two Pointers Work

Imagine a circular running track.

Two runners start at the same place:

- one runs slowly
- one runs twice as fast

Eventually the faster runner **laps the slower runner**.

This meeting guarantees that a **cycle exists**.

If the track was not circular, the faster runner would simply reach the finish line and stop.

This is exactly what happens in Floyd's algorithm.

---

### 4. Basic Linked List Setup

Consider a linked list:

```
A → B → C → D → E → F → null
```

This list has **no cycle**.

Now consider a list with a cycle:

```
A → B → C → D → E
        ↑       ↓
        H ← G ← F
```

Here the list loops back to `C`.

The structure never reaches `null`.

---

### 5. Floyd's Cycle Detection Algorithm

Steps:

1. Initialize two pointers

```
slow = head
fast = head
```

2. Move pointers

```
slow = slow.next
fast = fast.next.next
```

3. If fast reaches null

```
No cycle exists
```

4. If slow === fast

```
Cycle exists
```

---

### 6. JavaScript Implementation

```
function hasCycle(head) {

    let slow = head
    let fast = head

    while (fast && fast.next) {

        slow = slow.next
        fast = fast.next.next

        if (slow === fast) {
            return true
        }
    }

    return false
}
```

Explanation:

- slow moves one step
- fast moves two steps
- if they meet → cycle detected

---

### 7. Time and Space Complexity

Time Complexity:

```
O(n)
```

Both pointers traverse the list.

Space Complexity:

```
O(1)
```

No additional memory structures are used.

---

### 8. Finding the Start of the Cycle

Floyd's algorithm can also find **the exact node where the cycle begins**.

This is a famous follow-up question in interviews.

---

### 9. Why the Cycle Start Trick Works

Suppose:

```
distance from head to cycle start = a
distance inside cycle = b
cycle length = c
```

When slow and fast meet:

```
fast distance = 2 × slow distance
```

Mathematical derivation leads to:

```
distance from head to cycle start
=
distance from meeting point to cycle start
```

So if we:

1. keep one pointer at head
2. keep one pointer at meeting point
3. move both one step at a time

They meet exactly at the **cycle start node**.

---

### 10. Code to Find Cycle Start

```
function findCycleStart(head) {

    let slow = head
    let fast = head

    while (fast && fast.next) {

        slow = slow.next
        fast = fast.next.next

        if (slow === fast) {

            let pointer = head

            while (pointer !== slow) {
                pointer = pointer.next
                slow = slow.next
            }

            return pointer
        }
    }

    return null
}
```

---

### 11. Classic Interview Problem: Find Duplicate Number

This is one of the most famous applications of Floyd's algorithm.

Problem:

Given an array of size `n+1` containing numbers from `1..n`, find the duplicate number.

Example:

```
[1,3,4,2,2]
```

Output:

```
2
```

Constraints:

- cannot modify array
- constant space required

---

### 12. Why This Works

We treat the array as a **linked list**.

Each index points to the value at that index.

Example:

```
nums = [1,3,4,2,2]

0 → 1
1 → 3
3 → 2
2 → 4
4 → 2
```

This creates a cycle.

The duplicate number becomes the **entry point of the cycle**.

So Floyd’s algorithm finds the duplicate.

---

### 13. Code for Finding Duplicate Number

```
function findDuplicate(nums) {

    let slow = nums[0]
    let fast = nums[0]

    do {
        slow = nums[slow]
        fast = nums[nums[fast]]
    } while (slow !== fast)

    slow = nums[0]

    while (slow !== fast) {
        slow = nums[slow]
        fast = nums[fast]
    }

    return slow
}
```

Time Complexity:

```
O(n)
```

Space Complexity:

```
O(1)
```

---

### 14. Other Problems Using Floyd's Algorithm

Floyd’s cycle detection appears in multiple problems.

Common examples include:

Linked list cycle detection

```
Detect if list has loop
```

Linked list cycle start

```
Return node where loop begins
```

Find duplicate number

```
LeetCode 287
```

Happy number problem

```
Detect cycles in digit-square sequences
```

Cycle detection in generated sequences

---

### 15. How to Identify Floyd's Cycle Problems

These problems usually contain clues such as:

- sequence eventually repeats
- find duplicate without extra space
- detect loop in linked list
- numbers range from `1..n`
- array size `n+1`
- cannot modify input
- constant space constraint

If these appear together, Floyd's algorithm is often the intended solution.

---

### 16. Common Gotchas

Fast pointer null checks

Incorrect condition:

```
while (fast)
```

Correct condition:

```
while (fast && fast.next)
```

Otherwise accessing `fast.next.next` may cause errors.

---

Meeting point confusion

The meeting point is **not necessarily the cycle start**.

A second phase is required to locate the start node.

---

Array interpretation mistakes

In duplicate-number problems:

```
nums[i] is treated like next pointer
```

Many people fail to see the hidden linked list.

---

Infinite loops

Forgetting pointer movement conditions can create infinite loops.

Always ensure correct pointer updates.

---

### 17. Advantages of Floyd's Algorithm

The algorithm is powerful because it:

- uses constant memory
- detects cycles efficiently
- avoids hash sets
- works in multiple problem types

